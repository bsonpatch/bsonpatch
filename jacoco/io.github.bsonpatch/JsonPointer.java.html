<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonPointer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bsonpatch - RFC 6902 for Bson Values</a> &gt; <a href="index.source.html" class="el_package">io.github.bsonpatch</a> &gt; <span class="el_source">JsonPointer.java</span></div><h1>JsonPointer.java</h1><pre class="source lang-java linenums">package io.github.bsonpatch;


import org.bson.BsonValue;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Implements RFC 6901 (JSON Pointer)
 *
 * &lt;p&gt;For full details, please refer to &lt;a href=&quot;https://tools.ietf.org/html/rfc6901&quot;&gt;RFC 6901&lt;/a&gt;.
 *
 * &lt;p&gt;&lt;/p&gt;Generally, a JSON Pointer is a string representation of a path into a JSON document.
 * This class implements the RFC as closely as possible, and offers several helpers and
 * utility methods on top of it:
 *
 * &lt;pre&gt;
 *      // Parse, build or render a JSON pointer
 *      String path = &quot;/a/0/b/1&quot;;
 *      JsonPointer ptr1 = JsonPointer.{@link #parse}(path);
 *      JsonPointer ptr2 = JsonPointer.{@link #ROOT}.append(&quot;a&quot;).append(0).append(&quot;b&quot;).append(1);
 *      assert(ptr1.equals(ptr2));
 *      assert(path.equals(ptr1.toString()));
 *      assert(path.equals(ptr2.toString()));
 *
 *      // Evaluate a JSON pointer against a live document
 *      BsonDocument doc = BsonDocument.parse(&quot;{\&quot;foo\&quot;:[\&quot;bar\&quot;, \&quot;baz\&quot;]}&quot;);
 *      BsonValue baz = JsonPointer.parse(&quot;/foo/1&quot;).{@link #evaluate(BsonValue) evaluate}(doc);
 *      assert(baz.asString().getValue().equals(&quot;baz&quot;)); 
 *      
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Instances of {@link JsonPointer} and its constituent {@link RefToken}s are &lt;b&gt;immutable&lt;/b&gt;.
 *
 * @since 0.4.8
 */
public class JsonPointer implements Serializable {
    private final RefToken[] tokens;

    private static final long serialVersionUID = 7876822196894534620L;

    /** A JSON pointer representing the root node of a JSON document */
<span class="fc" id="L49">    public final static JsonPointer ROOT = new JsonPointer(new RefToken[] {});</span>

<span class="fc" id="L51">    private JsonPointer(RefToken[] tokens) {</span>
<span class="fc" id="L52">        this.tokens = tokens;</span>
<span class="fc" id="L53">    }</span>

    /**
     * Constructs a new pointer from a list of reference tokens.
     *
     * @param tokens The list of reference tokens from which to construct the new pointer. This list is not modified.
     */
<span class="fc" id="L60">    public JsonPointer(List&lt;RefToken&gt; tokens) {</span>
<span class="fc" id="L61">        this.tokens = tokens.toArray(new RefToken[0]);</span>
<span class="fc" id="L62">    }</span>

    /**
     * Parses a valid string representation of a JSON Pointer.
     *
     * @param path The string representation to be parsed.
     * @return An instance of {@link JsonPointer} conforming to the specified string representation.
     * @throws IllegalArgumentException The specified JSON Pointer is invalid.
     */
    public static JsonPointer parse(String path) throws IllegalArgumentException {
<span class="fc" id="L72">        StringBuilder reftoken = null;</span>
<span class="fc" id="L73">        List&lt;RefToken&gt; result = new ArrayList&lt;RefToken&gt;();</span>

<span class="fc bfc" id="L75" title="All 2 branches covered.">        for (int i = 0; i &lt; path.length(); ++i) {</span>
<span class="fc" id="L76">            char c = path.charAt(i);</span>

            // Require leading slash
<span class="fc bfc" id="L79" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">                if (c != '/') throw new IllegalArgumentException(&quot;Missing leading slash&quot;);</span>
<span class="fc" id="L81">                reftoken = new StringBuilder();</span>
<span class="fc" id="L82">                continue;</span>
            }

<span class="fc bfc" id="L85" title="All 3 branches covered.">            switch (c) {</span>
                // Escape sequences
                case '~':
<span class="fc bfc" id="L88" title="All 2 branches covered.">                    switch (path.charAt(++i)) {</span>
                        case '0':
                        case '1':
                        case '2':
<span class="fc" id="L92">                            reftoken.append('~');</span>
<span class="fc" id="L93">                            reftoken.append(path.charAt(i));</span>
<span class="fc" id="L94">                            break;</span>
                        default:
<span class="fc" id="L96">                            throw new IllegalArgumentException(&quot;Invalid escape sequence ~&quot; + path.charAt(i) + &quot; at index &quot; + i);</span>
                    }
                    break;

                // New reftoken
                case '/':
<span class="fc" id="L102">                    result.add(RefToken.parse(reftoken.toString()));</span>
<span class="fc" id="L103">                    reftoken.setLength(0);</span>
<span class="fc" id="L104">                    break;</span>

                default:
<span class="fc" id="L107">                    reftoken.append(c);</span>
                    break;
            }
        }

<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (reftoken == null)</span>
<span class="fc" id="L113">            return ROOT;</span>

<span class="fc" id="L115">        result.add(RefToken.parse(reftoken.toString()));</span>
<span class="fc" id="L116">        return new JsonPointer(result);</span>
    }

    /**
     * Indicates whether or not this instance points to the root of a JSON document.
     * @return {@code true} if this pointer represents the root node, {@code false} otherwise.
     */
    public boolean isRoot() {
<span class="fc bfc" id="L124" title="All 2 branches covered.">        return tokens.length == 0;</span>
    }

    /**
     * Creates a new JSON pointer to the specified field of the object referenced by this instance.
     *
     * @param field The desired field name, or any valid JSON Pointer reference token
     * @return The new {@link JsonPointer} instance.
     */
    JsonPointer append(String field) {
<span class="fc" id="L134">        RefToken[] newTokens = Arrays.copyOf(tokens, tokens.length + 1);</span>
<span class="fc" id="L135">        newTokens[tokens.length] = new RefToken(field, null, null);</span>
<span class="fc" id="L136">        return new JsonPointer(newTokens);</span>
    }

    /**
     * Creates a new JSON pointer to an indexed element of the array referenced by this instance.
     *
     * @param index The desired index, or {@link #LAST_INDEX} to point past the end of the array.
     * @return The new {@link JsonPointer} instance.
     */
    JsonPointer append(int index) {
<span class="fc" id="L146">        RefToken[] newTokens = Arrays.copyOf(tokens, tokens.length + 1);</span>
<span class="fc" id="L147">        newTokens[tokens.length] = new RefToken(Integer.toString(index), index, null);</span>
<span class="fc" id="L148">        return new JsonPointer(newTokens);</span>
    }

    /** Returns the number of reference tokens comprising this instance. */
    int size() {
<span class="fc" id="L153">        return tokens.length;</span>
    }

    /**
     * Returns a string representation of this instance
     *
     * @return
     *  An &lt;a href=&quot;https://tools.ietf.org/html/rfc6901#section-5&quot;&gt;RFC 6901 compliant&lt;/a&gt; string
     *  representation of this JSON pointer.
     */
    public String toString() {
<span class="fc" id="L164">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (RefToken token : tokens) {</span>
<span class="fc" id="L166">            sb.append('/');</span>
<span class="fc" id="L167">            sb.append(token);</span>
        }
<span class="fc" id="L169">        return sb.toString();</span>
    }

    /**
     * Decomposes this JSON pointer into its reference tokens.
     *
     * @return A list of {@link RefToken}s. Modifications to this list do not affect this instance.
     */
    public List&lt;RefToken&gt; decompose() {
<span class="fc" id="L178">        return Arrays.asList(tokens.clone());</span>
    }

    /**
     * Retrieves the reference token at the specified index.
     *
     * @param index The desired reference token index.
     * @return The specified instance of {@link RefToken}.
     * @throws IndexOutOfBoundsException The specified index is illegal.
     */
    public RefToken get(int index) throws IndexOutOfBoundsException {
<span class="pc bpc" id="L189" title="2 of 4 branches missed.">        if (index &lt; 0 || index &gt;= tokens.length) throw new IndexOutOfBoundsException(&quot;Illegal index: &quot; + index);</span>
<span class="fc" id="L190">        return tokens[index];</span>
    }

    /**
     * Retrieves the last reference token for this JSON pointer.
     *
     * @return The last {@link RefToken} comprising this instance.
     * @throws IllegalStateException Last cannot be called on {@link #ROOT root} pointers.
     */
    public RefToken last() {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (isRoot()) throw new IllegalStateException(&quot;Root pointers contain no reference tokens&quot;);</span>
<span class="fc" id="L201">        return tokens[tokens.length - 1];</span>
    }

    /**
     * Creates a JSON pointer to the parent of the node represented by this instance.
     *
     * The parent of the {@link #ROOT root} pointer is the root pointer itself.
     *
     * @return A {@link JsonPointer} to the parent node.
     */
    public JsonPointer getParent() {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        return isRoot() ? this : new JsonPointer(Arrays.copyOf(tokens, tokens.length - 1));</span>
    }

    private void error(int atToken, String message, BsonValue document) throws JsonPointerEvaluationException {
<span class="fc" id="L216">        throw new JsonPointerEvaluationException(</span>
                message,
<span class="fc" id="L218">                new JsonPointer(Arrays.copyOf(tokens, atToken)),</span>
                document);
    }

    /**
     * Takes a target document and resolves the node represented by this instance.
     *
     * The evaluation semantics are described in
     * &lt;a href=&quot;https://tools.ietf.org/html/rfc6901#section-4&quot;&gt;RFC 6901 sectino 4&lt;/a&gt;.
     *
     * @param document The target document against which to evaluate the JSON pointer.
     * @return The {@link BsonValue} resolved by evaluating this JSON pointer.
     * @throws JsonPointerEvaluationException The pointer could not be evaluated.
     */
    public BsonValue evaluate(final BsonValue document) throws JsonPointerEvaluationException {
<span class="fc" id="L233">    	BsonValue current = document;</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (int idx = 0; idx &lt; tokens.length; ++idx) {</span>
<span class="fc" id="L236">            final RefToken token = tokens[idx];</span>

<span class="fc bfc" id="L238" title="All 2 branches covered.">            if (current.isArray()) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                if (token.isArrayIndex()) {</span>
<span class="pc bpc" id="L240" title="1 of 4 branches missed.">                    if (token.getIndex() == LAST_INDEX || token.getIndex() &gt;= current.asArray().size())</span>
<span class="nc" id="L241">                        error(idx, &quot;Array index &quot; + token + &quot; is out of bounds&quot;, document);</span>
<span class="fc" id="L242">                    current = current.asArray().get(token.getIndex());</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">                } else if (token.isArrayKeyRef()) {</span>
<span class="fc" id="L244">                    KeyRef keyRef = token.getKeyRef();</span>
<span class="fc" id="L245">                    BsonValue foundArrayNode = null;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">                    for (int arrayIdx = 0; arrayIdx &lt; current.asArray().size(); ++arrayIdx) {</span>
<span class="fc" id="L247">                        BsonValue arrayNode = current.asArray().get(arrayIdx);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                        if (matches(keyRef, arrayNode)) {</span>
<span class="fc" id="L249">                            foundArrayNode = arrayNode;</span>
<span class="fc" id="L250">                            break;</span>
                        }
                    }
<span class="fc bfc" id="L253" title="All 2 branches covered.">                    if (foundArrayNode == null) {</span>
<span class="nc" id="L254">                        error(idx, &quot;Array has no matching object for key reference &quot; + token, document);</span>
                    }
<span class="fc" id="L256">                    current = foundArrayNode;</span>
<span class="fc" id="L257">                } else {</span>
<span class="nc" id="L258">                    error(idx, &quot;Can't reference field \&quot;&quot; + token.getField() + &quot;\&quot; on array&quot;, document);</span>
                }
            }
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">            else if (current.isDocument()) {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                if (!current.asDocument().containsKey(token.getField()))</span>
<span class="nc" id="L263">                    error(idx,&quot;Missing field \&quot;&quot; + token.getField() + &quot;\&quot;&quot;, document);</span>
<span class="fc" id="L264">                current = current.asDocument().get(token.getField());</span>
            }
            else
<span class="nc" id="L267">                error(idx, &quot;Can't reference past scalar value&quot;, document);</span>
        }

<span class="fc" id="L270">        return current;</span>
    }

    private boolean matches(KeyRef keyRef, BsonValue arrayNode) {
<span class="fc" id="L274">        boolean matches = false;</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (arrayNode.asDocument().containsKey(keyRef.key)) {</span>
<span class="fc" id="L276">            BsonValue valueNode = arrayNode.asDocument().get(keyRef.key);</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            if (valueNode.isString()) {</span>
<span class="fc" id="L278">                matches = Objects.equals(keyRef.value, valueNode.asString().getValue());</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">            } else if (valueNode.isNumber() || valueNode.isBoolean()) {</span>
<span class="nc" id="L280">                matches = Objects.equals(keyRef.value, valueNode.toString());</span>
            }
        }
<span class="fc" id="L283">        return matches;</span>
    }


    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L290" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>

<span class="fc" id="L292">        JsonPointer that = (JsonPointer) o;</span>

        // Probably incorrect - comparing Object[] arrays with Arrays.equals
<span class="fc" id="L295">        return Arrays.equals(tokens, that.tokens);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L300">        return Arrays.hashCode(tokens);</span>
    }

    /** Represents a single JSON Pointer reference token. */
    static class RefToken implements Serializable
    {
        private final String decodedToken;
        private final Integer index;
        private final KeyRef keyRef;

        private static final long serialVersionUID = -8672427347472605093L;

<span class="fc" id="L312">        private RefToken(String decodedToken, Integer arrayIndex, KeyRef arrayKeyRef) {</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">            if (decodedToken == null) throw new IllegalArgumentException(&quot;Token can't be null&quot;);</span>
<span class="fc" id="L314">            this.decodedToken = decodedToken;</span>
<span class="fc" id="L315">            this.index = arrayIndex;</span>
<span class="fc" id="L316">            this.keyRef = arrayKeyRef;</span>
<span class="fc" id="L317">        }</span>

<span class="fc" id="L319">        private static final Pattern DECODED_TILDA_PATTERN = Pattern.compile(&quot;~0&quot;);</span>
<span class="fc" id="L320">        private static final Pattern DECODED_SLASH_PATTERN = Pattern.compile(&quot;~1&quot;);</span>
<span class="fc" id="L321">        private static final Pattern DECODED_EQUALS_PATTERN = Pattern.compile(&quot;~2&quot;);</span>

        private static String decodePath(Object object) {
<span class="fc" id="L324">            String path = object.toString(); // see http://tools.ietf.org/html/rfc6901#section-4</span>
<span class="fc" id="L325">            path = DECODED_SLASH_PATTERN.matcher(path).replaceAll(&quot;/&quot;);</span>
<span class="fc" id="L326">            path = DECODED_TILDA_PATTERN.matcher(path).replaceAll(&quot;~&quot;);</span>
<span class="fc" id="L327">            return DECODED_EQUALS_PATTERN.matcher(path).replaceAll(&quot;=&quot;);</span>
        }

<span class="fc" id="L330">        private static final Pattern ENCODED_TILDA_PATTERN = Pattern.compile(&quot;~&quot;);</span>
<span class="fc" id="L331">        private static final Pattern ENCODED_SLASH_PATTERN = Pattern.compile(&quot;/&quot;);</span>
<span class="fc" id="L332">        private static final Pattern ENCODED_EQUALS_PATTERN = Pattern.compile(&quot;=&quot;);</span>

        private static String encodePath(Object object) {
<span class="fc" id="L335">            String path = object.toString(); // see http://tools.ietf.org/html/rfc6901#section-4</span>
<span class="fc" id="L336">            path = ENCODED_TILDA_PATTERN.matcher(path).replaceAll(&quot;~0&quot;);</span>
<span class="fc" id="L337">            path = ENCODED_SLASH_PATTERN.matcher(path).replaceAll(&quot;~1&quot;);</span>
<span class="fc" id="L338">            return ENCODED_EQUALS_PATTERN.matcher(path).replaceAll(&quot;~2&quot;);</span>
        }

<span class="fc" id="L341">        private static final Pattern VALID_ARRAY_IND = Pattern.compile(&quot;-|0|(?:[1-9][0-9]*)&quot;);</span>

<span class="fc" id="L343">        private static final Pattern VALID_ARRAY_KEY_REF = Pattern.compile(&quot;([^=]+)=([^=]+)&quot;);</span>

        public static RefToken parse(String rawToken) {
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">            if (rawToken == null) throw new IllegalArgumentException(&quot;Token can't be null&quot;);</span>

<span class="fc" id="L348">            Integer index = null;</span>
<span class="fc" id="L349">            Matcher indexMatcher = VALID_ARRAY_IND.matcher(rawToken);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            if (indexMatcher.matches()) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                if (indexMatcher.group().equals(&quot;-&quot;)) {</span>
<span class="fc" id="L352">                    index = LAST_INDEX;</span>
                } else {
                    try {
<span class="fc" id="L355">                        int validInt = Integer.parseInt(indexMatcher.group());</span>
<span class="fc" id="L356">                        index = validInt;</span>
<span class="fc" id="L357">                    } catch (NumberFormatException ignore) {}</span>
                }
            }

<span class="fc" id="L361">            KeyRef keyRef = null;</span>
<span class="fc" id="L362">            Matcher arrayKeyRefMatcher = VALID_ARRAY_KEY_REF.matcher(rawToken);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            if (arrayKeyRefMatcher.matches()) {</span>
<span class="fc" id="L364">                keyRef = new KeyRef(</span>
<span class="fc" id="L365">                        decodePath(arrayKeyRefMatcher.group(1)),</span>
<span class="fc" id="L366">                        decodePath(arrayKeyRefMatcher.group(2))</span>
                );
            }
<span class="fc" id="L369">            return new RefToken(decodePath(rawToken), index, keyRef);</span>
        }

        public boolean isArrayIndex() {
<span class="fc bfc" id="L373" title="All 2 branches covered.">            return index != null;</span>
        }

        public boolean isArrayKeyRef() {
<span class="fc bfc" id="L377" title="All 2 branches covered.">            return keyRef != null;</span>
        }

        public int getIndex() {
<span class="fc bfc" id="L381" title="All 2 branches covered.">            if (!isArrayIndex()) throw new IllegalStateException(&quot;Object operation on array index target&quot;);</span>
<span class="fc" id="L382">            return index;</span>
        }

        public KeyRef getKeyRef() {
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (!isArrayKeyRef()) throw new IllegalStateException(&quot;Object operation on array key ref target&quot;);</span>
<span class="fc" id="L387">            return keyRef;</span>
        }

        public String getField() {
<span class="fc" id="L391">            return decodedToken;</span>
        }

        @Override
        public String toString() {
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (isArrayKeyRef()) {</span>
<span class="fc" id="L397">                return encodePath(keyRef.key) + &quot;=&quot; + encodePath(keyRef.value);</span>
            } else {
<span class="fc" id="L399">                return encodePath(decodedToken);</span>
            }
        }

        @Override
        public boolean equals(Object o) {
<span class="fc bfc" id="L405" title="All 2 branches covered.">            if (this == o) return true;</span>
<span class="pc bpc" id="L406" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>

<span class="fc" id="L408">            RefToken refToken = (RefToken) o;</span>

<span class="fc" id="L410">            return decodedToken.equals(refToken.decodedToken);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L415">            return decodedToken.hashCode();</span>
        }
    }


    static class KeyRef implements Serializable {
        private String key;
        private String value;

        private static final long serialVersionUID = 6558265555055471373L;

<span class="fc" id="L426">        public KeyRef(String key, String value) {</span>
<span class="fc" id="L427">            this.key = key;</span>
<span class="fc" id="L428">            this.value = value;</span>
<span class="fc" id="L429">        }</span>

        @Override
        public boolean equals(Object o) {
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L434" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>

<span class="fc" id="L436">            KeyRef keyRef = (KeyRef) o;</span>

<span class="pc bpc" id="L438" title="2 of 4 branches missed.">            return Objects.equals(key, keyRef.key) &amp;&amp; Objects.equals(value, keyRef.value);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L443">            return Objects.hash(key, value);</span>
        }
    }

    /**
     * Represents an array index pointing past the end of the array.
     *
     * Such an index is represented by the JSON pointer reference token &quot;{@code -}&quot;; see
     * &lt;a href=&quot;https://tools.ietf.org/html/rfc6901#section-4&quot;&gt;RFC 6901 section 4&lt;/a&gt; for
     * more details.
     */
    final static int LAST_INDEX = Integer.MIN_VALUE;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>